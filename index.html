<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="十二月的doge">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="十二月的doge">
<meta property="article:author" content="GIO">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>

  <title>十二月的doge</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Navigationsleiste an/ausschalten">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">十二月的doge</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Startseite</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archiv</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/30/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/30/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">工厂模式（Factory）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2021-07-30 19:53:38 / Geändert am: 16:26:58" itemprop="dateCreated datePublished" datetime="2021-07-30T19:53:38+08:00">2021-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul>
<li>定义: 工厂模式(Factory Pattern)最常用的设计模式之一。这种类型的设计模式<br>数据创建型模式，提供了一种创建对象的最佳方式。</li>
<li>意图： 定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式<br>使其创建过程延迟到子类进行。</li>
<li>主要解决： 接口选择的问题。</li>
<li>何时使用： 明确地计划不同条件下创建不同实例时。</li>
<li>如何解决： 让其子类实现工厂接口，返回的也是一个抽象的产品。</li>
<li>关键代码： 创建过程在其子类执行。</li>
<li>简单来说： 简单工厂只是为客户端生成一个实例，而不会向客户端公开任何实例化逻辑。</li>
</ul>
<h3 id="现实场景的例子"><a href="#现实场景的例子" class="headerlink" title="现实场景的例子"></a>现实场景的例子</h3><ul>
<li>例如你需要炒菜,你就要在厨房中,找到你想要的厨具进行炒菜。</li>
</ul>
<h3 id="程序上的简单工厂实现"><a href="#程序上的简单工厂实现" class="headerlink" title="程序上的简单工厂实现"></a>程序上的简单工厂实现</h3><p>我们需要个简单的厨房</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class kitchenFactory &#123;</span><br><span class="line">	public function cooking(string $cooking)</span><br><span class="line">	&#123;</span><br><span class="line">		if ($cooking &#x3D;&#x3D; &#39;spoon&#39;) &#123;</span><br><span class="line">           	return new spoon;</span><br><span class="line">       	&#125; elseif ($cooking &#x3D;&#x3D; &#39;shovel&#39;) &#123;</span><br><span class="line">           	return new shovel;</span><br><span class="line">       	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class spoon &#123;</span><br><span class="line"></span><br><span class="line">	public function fry() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class shovel &#123;</span><br><span class="line">	public function fry() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就需要开始炒菜了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$kitchenFactory &#x3D; new kitchenFactory();</span><br><span class="line"></span><br><span class="line">$spoon &#x3D; $kitchenFactory-&gt;cooking(&#39;spoon&#39;);</span><br><span class="line">$spoon-&gt;fry();</span><br><span class="line"></span><br><span class="line">$shovel &#x3D; $kitchenFactory-&gt;cooking(&#39;shovel&#39;);</span><br><span class="line">$shovel-&gt;fry();</span><br></pre></td></tr></table></figure>
<p>需要采用工厂模式的时机</p>
<ul>
<li>当创建对象不仅仅是一些分配而且涉及一些逻辑时，将它放在专用的工厂中而不是在任何<br>地方重复相同的代码。</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>一个调用者想创建一个对象，只要知道其名称就可以了。</li>
<li>扩展性搞，如果想增加一个产品，只要扩展一个工厂类就可以了。</li>
<li>屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>每次新增加一个厨具的时候，我们就需要去工厂类添加一个判断与实例，这样就与设计模式中的开闭原则冲突了，所以接下来要说的是抽象的工厂。 </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/30/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/30/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/" class="post-title-link" itemprop="url">抽象工厂</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2021-07-30 16:49:18" itemprop="dateCreated datePublished" datetime="2021-07-30T16:49:18+08:00">2021-07-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/17/%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/17/%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90/" class="post-title-link" itemprop="url">'死锁分析'</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2021-07-17 14:05:14 / Geändert am: 15:54:42" itemprop="dateCreated datePublished" datetime="2021-07-17T14:05:14+08:00">2021-07-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>发现最近朋友们很关注死锁的有关知识点，今天特意开一篇文章来讲讲，我打算从两个角度来分析下死锁的问题。</p>
<h3 id="以下是朋友最关心的几个问题"><a href="#以下是朋友最关心的几个问题" class="headerlink" title="以下是朋友最关心的几个问题"></a>以下是朋友最关心的几个问题</h3><ul>
<li>什么是死锁？</li>
<li>死锁什么时候才会发生？</li>
<li>死锁产生的场景一般有哪些？</li>
<li>产生死锁的详细原因？<blockquote>
<p>接下来我会对以上的问题进行一些解答与回复。</p>
</blockquote>
</li>
</ul>
<h3 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h3><ul>
<li><p>百度上的定义: 死锁是指两个或以上的进程在执行过程中,由于竞争资源或者由于彼此通信而造成的一种阻塞现象。</p>
</li>
<li><p>mysql的死锁: 底层原理我认为也是由多个进程竞争资源导致，具体到mysql的话，可能就是两个或者多个事务都对同时段的数据进行操作时造成的阻塞现象。</p>
</li>
</ul>
<h3 id="死锁什么时候才会发生？"><a href="#死锁什么时候才会发生？" class="headerlink" title="死锁什么时候才会发生？"></a>死锁什么时候才会发生？</h3><ul>
<li><p>我的理解：当两个或以上的事务在执行时，事务A与事务B在同时段内对某行或者某个范围的内的数据进行操作时，可能事务A<br>在等待事务B的锁释放，而同时事务B可能也在等待着事务A的锁释放，这就可能导致双方无法继续执行，而在等待中。从而就产生了死锁。以下我会使用两个例子来诠释死锁的产生。</p>
</li>
<li><p>文档描述：当并发系统中不同线程出现循环资源依赖 涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁</p>
</li>
</ul>
<h3 id="死锁产生的场景？"><a href="#死锁产生的场景？" class="headerlink" title="死锁产生的场景？"></a>死锁产生的场景？</h3><ul>
<li>比如在一些长事务的应用场景下</li>
<li>并发过高的时候,可能会导致多个线程同时更新同一行</li>
</ul>
<h3 id="产生死锁的详细原因"><a href="#产生死锁的详细原因" class="headerlink" title="产生死锁的详细原因"></a>产生死锁的详细原因</h3><ul>
<li>系统资源有限</li>
<li>进程推进顺序不合理            </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/01/%E8%BF%9B%E7%A8%8B-%E5%8D%8F%E7%A8%8B-%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/01/%E8%BF%9B%E7%A8%8B-%E5%8D%8F%E7%A8%8B-%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">进程/协程/线程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2021-03-01 16:06:37 / Geändert am: 17:36:31" itemprop="dateCreated datePublished" datetime="2021-03-01T16:06:37+08:00">2021-03-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><blockquote>
<p>进程是系统资源分配的最小单位,系统由一个个进程(程序)组成一般情况下,包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。</p>
<ul>
<li>文本区域存储处理器执行的代码。</li>
<li>数据区域存储变量和进程执行期间使用的动态分配的内存;</li>
<li>堆栈区域存储着活动过程调用的指令和本地变量。</li>
</ul>
</blockquote>
<p>因此进程的创建和销毁都是相对于系统资源，所以是一种比较昂贵的操作。进程有三个状态：</p>
<ol>
<li>等待态：等待某个事件的完成；</li>
<li>就绪态：等待系统分配处理器以便运行；</li>
<li>运行态：占有处理器正在运行。</li>
</ol>
<p>进程是抢占式的争夺CPU运行自身，而CPU单核的情况下同时只能执行一个进程的代码，但是多进程的实现则是通过CPU飞快的切换不同进程，因此使得看上去就像是多个进程在同时进行。</p>
<p>进程一般由程序、数据集合和进程控制块三部分组成。</p>
<ul>
<li>程序用于描述进程要完成的功能，是控制进程执行的指令集；</li>
<li>数据集合是程序在执行时所需要的数据和工作区；</li>
<li>程序控制块（简称PCB）,包含进程的描述信息和控制信息，是进程存在的唯一标志；</li>
</ul>
<p>进程具有的特征：</p>
<ul>
<li>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；</li>
<li>并发性：任何进程都可以同其他进程一起并发执行；</li>
<li>独立性: 进程是系统进行资源分配和调度的一个独立单位；</li>
<li>结构性：进程由程序、数据和进程控制块三部分组成</li>
</ul>
<p>进程间通信：</p>
<blockquote>
<ul>
<li>管道</li>
<li>命名管道</li>
<li>消息队列 (MQ)</li>
<li>信号量</li>
<li>共享内存</li>
<li>套接字(Socket)</li>
</ul>
</blockquote>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><blockquote>
<ul>
<li>线程属于进程</li>
<li>线程共享进程的内存地址空间</li>
<li>线程几乎不占有系统资源</li>
</ul>
</blockquote>
<p>同时多线程是不安全的，当一个线程崩溃了，会导致整个进程也崩溃了，即其他线程也挂了，但多进程而不会，一个进程挂了，另一个进程依然照样运行。</p>
<ul>
<li>进程是系统分配资源的最小单位</li>
<li>线程是CPU调度的最小单位</li>
<li>由于默认进程内只有一个线程，所以多核CPU处理多进程就像是一个进程一个核心。</li>
</ul>
<h3 id="线程和进程的上下文切换"><a href="#线程和进程的上下文切换" class="headerlink" title="线程和进程的上下文切换"></a>线程和进程的上下文切换</h3><p>进程切换分三步</p>
<ol>
<li>切换页目录以使用新的地址空间</li>
<li>切换内核栈</li>
<li>切换硬件上下文</li>
</ol>
<p>而线程切换只需要第2、3步。因此进程的切换代价比较大</p>
<h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><blockquote>
<ul>
<li>协程是属于线程的。协程程序是在线程里面跑的，因此协程又称微线程和纤程等</li>
<li>协程没有线程的上下文切换消耗。协程的调度切换是用户(程序员)手动切换的，因此更加灵活,因此又叫用户空间线程。</li>
<li>原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。</li>
</ul>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/12/22/AMQP%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/22/AMQP%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">AMQP协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2020-12-22 10:27:50 / Geändert am: 14:26:36" itemprop="dateCreated datePublished" datetime="2020-12-22T10:27:50+08:00">2020-12-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="AMQP是什么"><a href="#AMQP是什么" class="headerlink" title="AMQP是什么"></a>AMQP是什么</h3><p>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是一个进程间传递异步消息的网络协议。</p>
<h3 id="AMQP模型"><a href="#AMQP模型" class="headerlink" title="AMQP模型"></a>AMQP模型</h3><p><img src="https://img-blog.csdn.net/20181022113306601?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY0MTgzMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"></p>
<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>发布者（Publisher）发布消息（Message），经由交换机（Exchange）。<br>交换机根据路由规则将收到的消息分发给与该交换机绑定的队列（Queue）。<br>最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。</p>
<h3 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h3><ol>
<li>发布者、交换机、队列、消费者都可以有多个。同时因为AMQP是一个网络协议，所以这个过程中的发布者，消费者，消息代理<br>可以分别存在于不同的设备上。</li>
</ol>
<p>2、发布者发布消息时可以给消息指定各种消息属性。有些属性有可能会被取消代理（Brokers）使用，然而其他的属性则是完全不<br>透明的，它们只能被接收消息的应用所使用。</p>
<p>3、从安全角度考虑，网络是不可靠的，又或是消费者在处理消息的过程中意外挂掉，这样没有处理成功的消息就会丢失。基于此原<br>因，AMQP模块包含了一个消息确认（Message Acknowledgements）机制：当一个消息从队列中投递给消费者后，不会立即从队列中<br>删除，直到它收到来自消费者的确认回执（Acknowledgement）后，才完全从队列中删除。</p>
<p>4、在某些情况下，例如当一个消息无法被成功路由时（无法从交换机分发到队列），消息或许会被返回给发布者并丢弃。或者，如果<br>消息代理执行了延期操作，消息会被放入一个所谓的死信队列中。此时，消息发布者可以选择某些参数来处理这些特殊情况。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/17/RabbitMq%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/RabbitMq%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">RabbitMq工作流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2020-09-17 14:41:33" itemprop="dateCreated datePublished" datetime="2020-09-17T14:41:33+08:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-12-22 10:28:10" itemprop="dateModified" datetime="2020-12-22T10:28:10+08:00">2020-12-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Rabbitmq的工作流程"><a href="#Rabbitmq的工作流程" class="headerlink" title="Rabbitmq的工作流程"></a>Rabbitmq的工作流程</h3><p><strong>RabbitMQ组成部分说明如下：</strong></p>
<ul>
<li>Broker:消息队列服务进程,此进程包括两个部分:Exchange和Queue.</li>
<li>Exchange:消息队列交换机,按一定的规则将消息路由转发到某个队列,对消息进行过滤。</li>
<li>Queue:消息队列,存储消息的队列,消息到达队列并转发给指定的消费方。</li>
<li>Producer:消息生产者,即生产方客户端,生产方客户端将消息发送给MQ。</li>
<li>Consumer:消息消费者,即消费方客户端,接收MQ转发的消息。</li>
</ul>
<p><strong>消息发布接收流程</strong></p>
<p>————发送消息————</p>
<ol>
<li>生产者和Broker建立TCP连接。</li>
<li>生产者和Broker建立通道。</li>
<li>生产者通过通道消息发送给Broker,由Exchange将消息进行转发。</li>
<li>Exchange将消息转发到指定的Queue(队列)</li>
</ol>
<p>————接收消息————</p>
<ol>
<li>消费者和Broker建立TCP连接。</li>
<li>消费者和Broker建立通道。</li>
<li>消费者监听指定的Queue(队列)</li>
<li>当有消息到达Queue时Broker默认将消息推送给消费者。</li>
<li>消费者接收到消息。</li>
</ol>
<p><strong>生产者操作流程</strong></p>
<ol>
<li>创建连接</li>
<li>创建通道</li>
<li>声明队列</li>
<li>发送消息</li>
</ol>
<p><strong>消费者操作流程</strong></p>
<ol>
<li>创建连接</li>
<li>创建通道</li>
<li>声明队列</li>
<li>监听队列</li>
<li>接收消息</li>
<li>ack回复</li>
</ol>
<p><strong>RabbitMQ工作模式</strong></p>
<ol>
<li>Work queues</li>
<li>Publish/Subscribe</li>
<li>Routing</li>
<li>Topics</li>
<li>Header</li>
<li>RPC</li>
</ol>
<h4 id="Work-queues"><a href="#Work-queues" class="headerlink" title="Work queues"></a>Work queues</h4><p>介绍：work queues与入门程序相比,多了一个消费端,两个消费端共同消费同一个队列的消息。</p>
<p>应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度.</p>
<p>测试：</p>
<ol>
<li>使用入门程序,启动多个消费者。</li>
<li>生产者发送多个消息。</li>
</ol>
<p>结果：</p>
<ol>
<li>一条消息只会被一个消费者接收。</li>
<li>rabbit采用轮询的方式将消息是平均发送给消费者的.</li>
<li>消费者在处理完某条消息后,才会收到下一条消息。</li>
</ol>
<h4 id="Publish-subscribe"><a href="#Publish-subscribe" class="headerlink" title="Publish/subscribe"></a>Publish/subscribe</h4><p>介绍: 发布订阅模式:</p>
<ol>
<li>每个消费者监听自己的队列。</li>
<li>生产者将消息发给broker,由交换机将消息转发到绑定此交换机的每个队列,每个绑定交换机的队列都将接收到消息。</li>
</ol>
<p>小结：</p>
<p>一 publish/subscribe与work queues有什么区别。</p>
<p>区别：</p>
<ol>
<li>work queues不用定义交换机,而publish/subscribe需要定义交换机.</li>
<li>publish/subscribe的生产方式是面向交换机发送消息,work queues的生产方式面向队列发送消息(底层使用默认交换机)。</li>
<li>publish/subscribe需要设置队列和交换机的绑定,work queues 不需要设置,实质上work queues会将队列绑定到默认的交换机。</li>
</ol>
<p>相同点:</p>
<p>所以两者实现的发布/订阅的效果是一样的.多个消费端监听同一个队列不会重复消费消息。</p>
<p>二 实质工作用什么 publish/subscribe 还是work queues。</p>
<p>建议使用publish/subscribe,发布订阅模式比工作队列模式更加强大,并且发布订阅模式可以指定自己专用的交换机</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/11/RabbitMQ%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/11/RabbitMQ%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">RabbitMQ的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2020-09-11 08:46:21" itemprop="dateCreated datePublished" datetime="2020-09-11T08:46:21+08:00">2020-09-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-12-22 10:28:18" itemprop="dateModified" datetime="2020-12-22T10:28:18+08:00">2020-12-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-消息基于什么传输？"><a href="#1-消息基于什么传输？" class="headerlink" title="1.消息基于什么传输？"></a>1.消息基于什么传输？</h3><p>由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使用信道的<br>方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</p>
<h3 id="2-消息如何分布？"><a href="#2-消息如何分布？" class="headerlink" title="2.消息如何分布？"></a>2.消息如何分布？</h3><p>若该队列至少有一个消费者订阅，消息将以循环(round-robin)的方式发送给消费者。每条消息只会分<br>发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。</p>
<h3 id="3-如何确保消息正确地发送至RabbitMQ"><a href="#3-如何确保消息正确地发送至RabbitMQ" class="headerlink" title="3.如何确保消息正确地发送至RabbitMQ?"></a>3.如何确保消息正确地发送至RabbitMQ?</h3><p>RabbitMQ使用发送方确认模式，确保消息正确地发送到RabbitMQ。发送方确认模式：将信道设置成confirm<br>模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。一旦消息被投递到目<br>的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（发送消息唯一<br>ID）。如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（not acknowledged，未确认<br>）消息。发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息<br>到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</p>
<h3 id="4-如何确保消息接收方消费了消息？"><a href="#4-如何确保消息接收方消费了消息？" class="headerlink" title="4.如何确保消息接收方消费了消息？"></a>4.如何确保消息接收方消费了消息？</h3><p>接收方消息确认机制：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）<br>。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ<br>仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了<br>Consumer足够长的时间来处理消息。<br>会有以下几种特殊情况：</p>
<ul>
<li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后<br>重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）</li>
<li>如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该<br>消费者分发更多的消息。</li>
</ul>
<h3 id="5-如何避免消息重复投递或重复消费？"><a href="#5-如何避免消息重复投递或重复消费？" class="headerlink" title="5. 如何避免消息重复投递或重复消费？"></a>5. 如何避免消息重复投递或重复消费？</h3><p>在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。</p>
<p>这个问题针对业务场景来答分以下几点：</p>
<ul>
<li><p>比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</p>
</li>
<li><p>再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。</p>
</li>
<li><p>如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</p>
</li>
</ul>
<h3 id="6-生产者丢数据"><a href="#6-生产者丢数据" class="headerlink" title="6.生产者丢数据"></a>6.生产者丢数据</h3><p>生产者的消息没有投递到MQ中怎么办？从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。</p>
<p>transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。</p>
<p>然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作</p>
<h3 id="7-消息队列丢数据"><a href="#7-消息队列丢数据" class="headerlink" title="7.消息队列丢数据"></a>7.消息队列丢数据</h3><p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p>
<p>那么如何持久化呢？<br>①、将queue的持久化标识durable设置为true,则代表是一个持久的队列.<br>②、发送消息的时候将deliveryMode=2</p>
<p>这样设置以后，rabbitMQ就算挂了，重启后也能恢复数据。在消息还没有持久化到硬盘时，可能服务已经死掉，这种情况可以通过引入mirrored-queue即镜像队列，但也不能保证消息百分百不丢失（整个集群都挂掉）</p>
<h3 id="8-消费者丢数据"><a href="#8-消费者丢数据" class="headerlink" title="8.消费者丢数据"></a>8.消费者丢数据</h3><p>启用手动确认模式可以解决这个问题</p>
<ul>
<li><p>自动确认模式，消费者挂掉，待ack的消息回归到队列中。消费者抛出异常，消息会不断的被重发，直到处理成功。不会丢失消息，即便服务挂掉，没有处理完成的消息会重回队列，但是异常会让消息不断重试。</p>
</li>
<li><p>手动确认模式，如果消费者来不及处理就死掉时，没有响应ack时会重复发送一条信息给其他消费者；如果监听程序处理异常了，且未对异常进行捕获，会一直重复接收消息，然后一直抛异常；如果对异常进行了捕获，但是没有在finally里ack，也会一直重复发送消息(重试机制)。</p>
</li>
<li><p>不确认模式，acknowledge=”none” 不使用确认机制，只要消息发送完成会立即在队列移除，无论客户端异常还是断开，只要发送完就移除，不会重发。</p>
</li>
</ul>
<h3 id="使用消息队列会有什么缺点？"><a href="#使用消息队列会有什么缺点？" class="headerlink" title="使用消息队列会有什么缺点？"></a>使用消息队列会有什么缺点？</h3><ul>
<li><p>系统可用性降低:你想啊，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低。</p>
</li>
<li><p>系统复杂性增加:要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/06/elasticsearch%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/06/elasticsearch%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA/" class="post-title-link" itemprop="url">elasticsearch索引创建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2020-08-06 14:31:06 / Geändert am: 14:45:38" itemprop="dateCreated datePublished" datetime="2020-08-06T14:31:06+08:00">2020-08-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Elasticsearch-7-X版本创建索引"><a href="#Elasticsearch-7-X版本创建索引" class="headerlink" title="Elasticsearch 7.X版本创建索引"></a>Elasticsearch 7.X版本创建索引</h3><ul>
<li>编写索引文件,如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$params &#x3D; [</span><br><span class="line">            &#39;index&#39; &#x3D;&gt; &#39;my_index&#39;,</span><br><span class="line">            &#39;body&#39; &#x3D;&gt; [</span><br><span class="line">            	&#39;order&#39; &#x3D;&gt; 0, &#x2F;&#x2F; 模板优先级 越大优先级越高</span><br><span class="line">                &#39;settings&#39; &#x3D;&gt; [</span><br><span class="line">                	&#39;refresh_interval&#39; &#x3D;&gt; &quot;10s&quot;, &#x2F;&#x2F; 每10秒刷新</span><br><span class="line">                    &#39;number_of_shards&#39; &#x3D;&gt; 3, &#x2F;&#x2F; 主分片数量</span><br><span class="line">                    &#39;number_of_replicas&#39; &#x3D;&gt; 2 &#x2F;&#x2F; 副本数量</span><br><span class="line">                    &#39;translog&#39; &#x3D;&gt; [</span><br><span class="line">                    	&quot;flush_threshold_size&quot; &#x3D;&gt; &quot;1gb&quot;, &#x2F;&#x2F; 内容容量到达1gb异步刷新</span><br><span class="line">                    	&quot;sync_interval&quot; &#x3D;&gt; &quot;30s&quot;, &#x2F;&#x2F; 间隔30s异步刷新（设置后无法更改）</span><br><span class="line">                    	&quot;durability&quot;&#x3D;&gt;&quot;async&quot; &#x2F;&#x2F; 异步刷新</span><br><span class="line">                    ]</span><br><span class="line">                ],</span><br><span class="line">                &#39;mappings&#39; &#x3D;&gt; [ &#x2F;&#x2F; 索引中各字段的映射定义</span><br><span class="line">                    &#39;properties&#39; &#x3D;&gt; [</span><br><span class="line">                        &#39;name&#39; &#x3D;&gt; [</span><br><span class="line">                            &#39;type&#39; &#x3D;&gt; &#39;text&#39;,</span><br><span class="line">                            &#39;analyzer&#39; &#x3D;&gt; &#39;ik_max_word&#39;, &#x2F;&#x2F; 分析器</span><br><span class="line">                            &#39;search_analyzer&#39; &#x3D;&gt; &#39;ik_smart&#39;</span><br><span class="line">                        ],</span><br><span class="line">                        &#39;age&#39; &#x3D;&gt; [</span><br><span class="line">                            &#39;type&#39; &#x3D;&gt; &#39;integer&#39;</span><br><span class="line">                        ]</span><br><span class="line">                    ]</span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        ];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>连接Elasticsearch的客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$hosts &#x3D; [127.0.0.1:9200];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;setRetries 设置链接次数，例如，如果你有 10 个节点，设置 setRetries(5) ，客户端便会最多发送 5 次连接命令。如果 5 个节点返回的结果都是 connection timeout，那么客户端会抛出 OperationTimeoutException 。由于连接池处于使用状态，这些节点也可能会被标记为死节点。</span><br><span class="line"></span><br><span class="line">$client &#x3D; \Elasticsearch\ClientBuilder::create()</span><br><span class="line">	-&gt;setHosts($hosts)</span><br><span class="line">	-&gt;setRetries(3)</span><br><span class="line">	-&gt;build();</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建索引</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$es &#x3D; $client-&gt;create($params);  &#x2F;&#x2F;create当存在相同的index+type+id的时候报错</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/05/es%E6%90%9C%E7%B4%A2%E8%AF%AD%E5%8F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/05/es%E6%90%9C%E7%B4%A2%E8%AF%AD%E5%8F%A5/" class="post-title-link" itemprop="url">elasticsearch查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2020-08-05 14:14:40" itemprop="dateCreated datePublished" datetime="2020-08-05T14:14:40+08:00">2020-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2020-08-06 14:31:10" itemprop="dateModified" datetime="2020-08-06T14:31:10+08:00">2020-08-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>查询和”我的php学习生涯”这个查询语句匹配的文档.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">	 &quot;bool&quot;: &#123;</span><br><span class="line">		&quot;must&quot;: [&#123;</span><br><span class="line">			&quot;match&quot;: &#123;</span><br><span class="line">			   &quot;standard_name&quot;: &quot;初级php学习生涯&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="match-phrase-精确查询"><a href="#match-phrase-精确查询" class="headerlink" title="match_phrase 精确查询"></a>match_phrase 精确查询</h3><p>比如上面的例子,一个文档里面有”学点java中级也是不错”也会被搜索出来,那么想要精确匹配所有同时包含”初级php 学习 生涯”的文档。就要使用match_phrase.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;bool&quot;: &#123;</span><br><span class="line">			&quot;must&quot;: [&#123;</span><br><span class="line">				&quot;match_phrase&quot;: &#123;</span><br><span class="line">					&quot;standard_name&quot;: &quot;初级php学习生涯&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h3><p>如果我们希望两个字段进行匹配,其中一个字段有这个文档就满足的话，使用multi_match。可能需要使用bool查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;bool&quot;: &#123;</span><br><span class="line">			&quot;must&quot;: [</span><br><span class="line">				&#123;</span><br><span class="line">					&quot;multi_match&quot;: &#123;</span><br><span class="line">						&quot;query&quot;: &quot;我爱php&quot;,</span><br><span class="line">						&quot;fields&quot;: [&quot;product_name&quot;, &quot;standard_name&quot;]</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望完全匹配的文档占的评分比较高，则需要使用best_fields</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;bool&quot;: &#123;</span><br><span class="line">			&quot;must&quot;: [</span><br><span class="line">				&#123;</span><br><span class="line">					&quot;multi_match&quot;: &#123;</span><br><span class="line">						&quot;query&quot;: &quot;学习使我快乐&quot;,</span><br><span class="line">						&quot;fields&quot;: [&quot;product_name&quot;, &quot;standard_name&quot;],</span><br><span class="line">						&quot;type&quot;: &quot;best_fields&quot;,</span><br><span class="line">						&quot;tie_breaker&quot;: 0.3</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>意思就是完全匹配”学习 快乐”的文档评分会比较靠前，如果只匹配学习的文档评分乘以0.3的系数</li>
</ul>
<p>我们希望越多字段匹配的文档评分越高，就要使用most_fields</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;bool&quot;: &#123;</span><br><span class="line">			&quot;must&quot;: [</span><br><span class="line">				&#123;</span><br><span class="line">					&quot;multi_match&quot;: &#123;</span><br><span class="line">						&quot;query&quot;: &quot;学习使我快乐&quot;,</span><br><span class="line">						&quot;fields&quot;: [&quot;product_name&quot;, &quot;standard_name&quot;],</span><br><span class="line">						&quot;type&quot;: &quot;most_fields&quot;https:&#x2F;&#x2F;unsplash.com&#x2F;photos&#x2F;pKXalTOLVV4</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="term-精确查询"><a href="#term-精确查询" class="headerlink" title="term 精确查询"></a>term 精确查询</h3><p>term是代表完全匹配,即不进行分词器分析，文档中必须包含整个搜索的词汇。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;content&quot;: &quot;最爱php&quot;   &#x2F;&#x2F; content 查询的字段名</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用term要确定的是这个字段是否“被分析”(analyzed)，默认的字符串是被分析的。</p>
</blockquote>
<h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>一个布尔过滤器由三部分组成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;bool&quot; : &#123;</span><br><span class="line">      &quot;must&quot; :     [],</span><br><span class="line">      &quot;should&quot; :   [],</span><br><span class="line">      &quot;must_not&quot; : [],</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>must 所有的语句都必须 (must) 匹配,与AND等价</li>
<li>must_not 所有的语句都不能（must not）匹配, 与 NOT 等价。</li>
<li>should 至少有一个语句要匹配,与OR等价</li>
</ul>
<h4 id="一个-bool-查询包含一个-filter-过滤器和一个普通查询。"><a href="#一个-bool-查询包含一个-filter-过滤器和一个普通查询。" class="headerlink" title="一个 bool 查询包含一个 filter 过滤器和一个普通查询。"></a>一个 bool 查询包含一个 filter 过滤器和一个普通查询。</h4><p>一个查询语句究竟具有什么样的行为和得到什么结果,主要取决于它到底是处Query还是Filter,两者有很大区别，例如：</p>
<ul>
<li>① Query context 查询上下文 这种语句在执行时既要计算文档是否匹配,还要计算文档相对于其他文档的匹配度有多高,匹配度越高，score分数就越高。 </li>
<li>② Filter context 过滤上下文，过滤上下文中的语句在执行时只关心文档是否和查询匹配，不会计算匹配度，也就是得分。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;bool&quot;: &#123;</span><br><span class="line">			&quot;must&quot;: [&#123;</span><br><span class="line">				&quot;match&quot;: &#123;</span><br><span class="line">					&quot;standard_name&quot;: &quot;我爱口服液&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;],</span><br><span class="line">			&quot;filter&quot;: &#123;</span><br><span class="line">				&quot;match&quot;: &#123;</span><br><span class="line">					&quot;product_name&quot;: &quot;口服液&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上面的例子分析如下：</p>
<ol>
<li><strong>query</strong> 参数表示整个语句是处于query context中。</li>
<li><strong>bool</strong> 和 <strong>match</strong>语句被用在query context中，也就是说它们会计算每个文档的匹配度(score).</li>
<li><strong>filter</strong>参数则表示这个子查询处于filter context中。</li>
<li><strong>filter</strong>语句中的<strong>term</strong>和<strong>range</strong>语句用在filter context中，它们只起到过滤的作用，并不会计算文档的得分。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/23/%E5%95%86%E5%9F%8E%E6%89%A3%E5%87%8F%E5%BA%93%E5%AD%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/23/%E5%95%86%E5%9F%8E%E6%89%A3%E5%87%8F%E5%BA%93%E5%AD%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">商城扣减库存的几种方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2020-07-23 16:14:32 / Geändert am: 16:20:30" itemprop="dateCreated datePublished" datetime="2020-07-23T16:14:32+08:00">2020-07-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="下单扣减库存"><a href="#下单扣减库存" class="headerlink" title="下单扣减库存"></a>下单扣减库存</h3><blockquote>
<p>买家下单后，在商品的总库存中减去买家购买数量。下单减库存时最简单的减库存的方式，也是控制最精确的一种，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的情况。但是你要知道，有些人下完单可能并不会付款。</p>
</blockquote>
<h3 id="付款减库存"><a href="#付款减库存" class="headerlink" title="付款减库存"></a>付款减库存</h3><blockquote>
<p>买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。</p>
</blockquote>
<h3 id="预扣库存"><a href="#预扣库存" class="headerlink" title="预扣库存"></a>预扣库存</h3><blockquote>
<p>这种方式相对复杂一些，买家下单后，库存为其保留一定的时间(如10分钟),超过这个时间，库存将会自动释放，释放后其他买家就继续购买，在买家付款前，系统会校验该订单的库存是否还有保留，如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">GIO</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">schlagwörter</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GIO</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
