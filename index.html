<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="十二月的doge">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="十二月的doge">
<meta property="article:author" content="GIO">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'default'
  };
</script>

  <title>十二月的doge</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="تشغيل شريط التصفح">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">十二月的doge</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>الأرشيفات</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/06/elasticsearch%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/06/elasticsearch%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA/" class="post-title-link" itemprop="url">elasticsearch索引创建</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2020-08-06 14:31:06 / عُدل: 14:45:38" itemprop="dateCreated datePublished" datetime="2020-08-06T14:31:06+08:00">2020-08-06</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Elasticsearch-7-X版本创建索引"><a href="#Elasticsearch-7-X版本创建索引" class="headerlink" title="Elasticsearch 7.X版本创建索引"></a>Elasticsearch 7.X版本创建索引</h3><ul>
<li>编写索引文件,如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$params &#x3D; [</span><br><span class="line">            &#39;index&#39; &#x3D;&gt; &#39;my_index&#39;,</span><br><span class="line">            &#39;body&#39; &#x3D;&gt; [</span><br><span class="line">            	&#39;order&#39; &#x3D;&gt; 0, &#x2F;&#x2F; 模板优先级 越大优先级越高</span><br><span class="line">                &#39;settings&#39; &#x3D;&gt; [</span><br><span class="line">                	&#39;refresh_interval&#39; &#x3D;&gt; &quot;10s&quot;, &#x2F;&#x2F; 每10秒刷新</span><br><span class="line">                    &#39;number_of_shards&#39; &#x3D;&gt; 3, &#x2F;&#x2F; 主分片数量</span><br><span class="line">                    &#39;number_of_replicas&#39; &#x3D;&gt; 2 &#x2F;&#x2F; 副本数量</span><br><span class="line">                    &#39;translog&#39; &#x3D;&gt; [</span><br><span class="line">                    	&quot;flush_threshold_size&quot; &#x3D;&gt; &quot;1gb&quot;, &#x2F;&#x2F; 内容容量到达1gb异步刷新</span><br><span class="line">                    	&quot;sync_interval&quot; &#x3D;&gt; &quot;30s&quot;, &#x2F;&#x2F; 间隔30s异步刷新（设置后无法更改）</span><br><span class="line">                    	&quot;durability&quot;&#x3D;&gt;&quot;async&quot; &#x2F;&#x2F; 异步刷新</span><br><span class="line">                    ]</span><br><span class="line">                ],</span><br><span class="line">                &#39;mappings&#39; &#x3D;&gt; [ &#x2F;&#x2F; 索引中各字段的映射定义</span><br><span class="line">                    &#39;properties&#39; &#x3D;&gt; [</span><br><span class="line">                        &#39;name&#39; &#x3D;&gt; [</span><br><span class="line">                            &#39;type&#39; &#x3D;&gt; &#39;text&#39;,</span><br><span class="line">                            &#39;analyzer&#39; &#x3D;&gt; &#39;ik_max_word&#39;, &#x2F;&#x2F; 分析器</span><br><span class="line">                            &#39;search_analyzer&#39; &#x3D;&gt; &#39;ik_smart&#39;</span><br><span class="line">                        ],</span><br><span class="line">                        &#39;age&#39; &#x3D;&gt; [</span><br><span class="line">                            &#39;type&#39; &#x3D;&gt; &#39;integer&#39;</span><br><span class="line">                        ]</span><br><span class="line">                    ]</span><br><span class="line">                ]</span><br><span class="line">            ]</span><br><span class="line">        ];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>连接Elasticsearch的客户端</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$hosts &#x3D; [127.0.0.1:9200];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;setRetries 设置链接次数，例如，如果你有 10 个节点，设置 setRetries(5) ，客户端便会最多发送 5 次连接命令。如果 5 个节点返回的结果都是 connection timeout，那么客户端会抛出 OperationTimeoutException 。由于连接池处于使用状态，这些节点也可能会被标记为死节点。</span><br><span class="line"></span><br><span class="line">$client &#x3D; \Elasticsearch\ClientBuilder::create()</span><br><span class="line">	-&gt;setHosts($hosts)</span><br><span class="line">	-&gt;setRetries(3)</span><br><span class="line">	-&gt;build();</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建索引</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$es &#x3D; $client-&gt;create($params);  &#x2F;&#x2F;create当存在相同的index+type+id的时候报错</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/05/es%E6%90%9C%E7%B4%A2%E8%AF%AD%E5%8F%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/05/es%E6%90%9C%E7%B4%A2%E8%AF%AD%E5%8F%A5/" class="post-title-link" itemprop="url">elasticsearch查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-08-05 14:14:40" itemprop="dateCreated datePublished" datetime="2020-08-05T14:14:40+08:00">2020-08-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-08-06 14:31:10" itemprop="dateModified" datetime="2020-08-06T14:31:10+08:00">2020-08-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>查询和”我的php学习生涯”这个查询语句匹配的文档.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">	 &quot;bool&quot;: &#123;</span><br><span class="line">		&quot;must&quot;: [&#123;</span><br><span class="line">			&quot;match&quot;: &#123;</span><br><span class="line">			   &quot;standard_name&quot;: &quot;初级php学习生涯&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="match-phrase-精确查询"><a href="#match-phrase-精确查询" class="headerlink" title="match_phrase 精确查询"></a>match_phrase 精确查询</h3><p>比如上面的例子,一个文档里面有”学点java中级也是不错”也会被搜索出来,那么想要精确匹配所有同时包含”初级php 学习 生涯”的文档。就要使用match_phrase.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;bool&quot;: &#123;</span><br><span class="line">			&quot;must&quot;: [&#123;</span><br><span class="line">				&quot;match_phrase&quot;: &#123;</span><br><span class="line">					&quot;standard_name&quot;: &quot;初级php学习生涯&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="multi-match"><a href="#multi-match" class="headerlink" title="multi_match"></a>multi_match</h3><p>如果我们希望两个字段进行匹配,其中一个字段有这个文档就满足的话，使用multi_match。可能需要使用bool查询</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;bool&quot;: &#123;</span><br><span class="line">			&quot;must&quot;: [</span><br><span class="line">				&#123;</span><br><span class="line">					&quot;multi_match&quot;: &#123;</span><br><span class="line">						&quot;query&quot;: &quot;我爱php&quot;,</span><br><span class="line">						&quot;fields&quot;: [&quot;product_name&quot;, &quot;standard_name&quot;]</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们希望完全匹配的文档占的评分比较高，则需要使用best_fields</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;bool&quot;: &#123;</span><br><span class="line">			&quot;must&quot;: [</span><br><span class="line">				&#123;</span><br><span class="line">					&quot;multi_match&quot;: &#123;</span><br><span class="line">						&quot;query&quot;: &quot;学习使我快乐&quot;,</span><br><span class="line">						&quot;fields&quot;: [&quot;product_name&quot;, &quot;standard_name&quot;],</span><br><span class="line">						&quot;type&quot;: &quot;best_fields&quot;,</span><br><span class="line">						&quot;tie_breaker&quot;: 0.3</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>意思就是完全匹配”学习 快乐”的文档评分会比较靠前，如果只匹配学习的文档评分乘以0.3的系数</li>
</ul>
<p>我们希望越多字段匹配的文档评分越高，就要使用most_fields</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;bool&quot;: &#123;</span><br><span class="line">			&quot;must&quot;: [</span><br><span class="line">				&#123;</span><br><span class="line">					&quot;multi_match&quot;: &#123;</span><br><span class="line">						&quot;query&quot;: &quot;学习使我快乐&quot;,</span><br><span class="line">						&quot;fields&quot;: [&quot;product_name&quot;, &quot;standard_name&quot;],</span><br><span class="line">						&quot;type&quot;: &quot;most_fields&quot;https:&#x2F;&#x2F;unsplash.com&#x2F;photos&#x2F;pKXalTOLVV4</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="term-精确查询"><a href="#term-精确查询" class="headerlink" title="term 精确查询"></a>term 精确查询</h3><p>term是代表完全匹配,即不进行分词器分析，文档中必须包含整个搜索的词汇。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;content&quot;: &quot;最爱php&quot;   &#x2F;&#x2F; content 查询的字段名</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用term要确定的是这个字段是否“被分析”(analyzed)，默认的字符串是被分析的。</p>
</blockquote>
<h3 id="布尔查询"><a href="#布尔查询" class="headerlink" title="布尔查询"></a>布尔查询</h3><p>一个布尔过滤器由三部分组成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;bool&quot; : &#123;</span><br><span class="line">      &quot;must&quot; :     [],</span><br><span class="line">      &quot;should&quot; :   [],</span><br><span class="line">      &quot;must_not&quot; : [],</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>must 所有的语句都必须 (must) 匹配,与AND等价</li>
<li>must_not 所有的语句都不能（must not）匹配, 与 NOT 等价。</li>
<li>should 至少有一个语句要匹配,与OR等价</li>
</ul>
<h4 id="一个-bool-查询包含一个-filter-过滤器和一个普通查询。"><a href="#一个-bool-查询包含一个-filter-过滤器和一个普通查询。" class="headerlink" title="一个 bool 查询包含一个 filter 过滤器和一个普通查询。"></a>一个 bool 查询包含一个 filter 过滤器和一个普通查询。</h4><p>一个查询语句究竟具有什么样的行为和得到什么结果,主要取决于它到底是处Query还是Filter,两者有很大区别，例如：</p>
<ul>
<li>① Query context 查询上下文 这种语句在执行时既要计算文档是否匹配,还要计算文档相对于其他文档的匹配度有多高,匹配度越高，score分数就越高。 </li>
<li>② Filter context 过滤上下文，过滤上下文中的语句在执行时只关心文档是否和查询匹配，不会计算匹配度，也就是得分。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;bool&quot;: &#123;</span><br><span class="line">			&quot;must&quot;: [&#123;</span><br><span class="line">				&quot;match&quot;: &#123;</span><br><span class="line">					&quot;standard_name&quot;: &quot;我爱口服液&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;],</span><br><span class="line">			&quot;filter&quot;: &#123;</span><br><span class="line">				&quot;match&quot;: &#123;</span><br><span class="line">					&quot;product_name&quot;: &quot;口服液&quot;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对上面的例子分析如下：</p>
<ol>
<li><strong>query</strong> 参数表示整个语句是处于query context中。</li>
<li><strong>bool</strong> 和 <strong>match</strong>语句被用在query context中，也就是说它们会计算每个文档的匹配度(score).</li>
<li><strong>filter</strong>参数则表示这个子查询处于filter context中。</li>
<li><strong>filter</strong>语句中的<strong>term</strong>和<strong>range</strong>语句用在filter context中，它们只起到过滤的作用，并不会计算文档的得分。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/23/%E5%95%86%E5%9F%8E%E6%89%A3%E5%87%8F%E5%BA%93%E5%AD%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/23/%E5%95%86%E5%9F%8E%E6%89%A3%E5%87%8F%E5%BA%93%E5%AD%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">商城扣减库存的几种方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2020-07-23 16:14:32 / عُدل: 16:20:30" itemprop="dateCreated datePublished" datetime="2020-07-23T16:14:32+08:00">2020-07-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="下单扣减库存"><a href="#下单扣减库存" class="headerlink" title="下单扣减库存"></a>下单扣减库存</h3><blockquote>
<p>买家下单后，在商品的总库存中减去买家购买数量。下单减库存时最简单的减库存的方式，也是控制最精确的一种，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的情况。但是你要知道，有些人下完单可能并不会付款。</p>
</blockquote>
<h3 id="付款减库存"><a href="#付款减库存" class="headerlink" title="付款减库存"></a>付款减库存</h3><blockquote>
<p>买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。</p>
</blockquote>
<h3 id="预扣库存"><a href="#预扣库存" class="headerlink" title="预扣库存"></a>预扣库存</h3><blockquote>
<p>这种方式相对复杂一些，买家下单后，库存为其保留一定的时间(如10分钟),超过这个时间，库存将会自动释放，释放后其他买家就继续购买，在买家付款前，系统会校验该订单的库存是否还有保留，如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/22/%E9%92%88%E5%AF%B9%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E7%9A%84%E6%96%B9%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/22/%E9%92%88%E5%AF%B9%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%E7%9A%84%E6%96%B9%E6%B3%95/" class="post-title-link" itemprop="url">针对秒杀场景的方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2020-07-22 16:18:51 / عُدل: 18:51:29" itemprop="dateCreated datePublished" datetime="2020-07-22T16:18:51+08:00">2020-07-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="排队方式"><a href="#排队方式" class="headerlink" title="排队方式"></a>排队方式</h3><ul>
<li>利用线程池加锁等待也是一种常用的排队方式。</li>
<li>先进先出，先进后出等常用的内存排队算法的实现方式；</li>
<li>把请求序列化到文件中，然后再顺序地读文件（例如基于MySQL binlog的同步机制）来恢复请求等方式。</li>
</ul>
<blockquote>
<ol>
<li>通过把”一步的操作” 变成”两步的操作。”。起到缓冲的作用。2.延缓请求，起到对请求流量进行削峰的作用。</li>
</ol>
</blockquote>
<h3 id="分层过滤"><a href="#分层过滤" class="headerlink" title="分层过滤"></a>分层过滤</h3><p>假如请求分别经过 CDN、前台读系统（如商品详情系统）、后台系统（如交易系统）和数据库这几层，那么：</p>
<ul>
<li>大部分数据和流量在用户浏览器或者CDN上获取，这一层可以拦截大部分数据的读取；</li>
<li>经过第二层（即前台系统）时数据（包括强一致性的数据）尽量得走Cache，过滤一些无效的请求；</li>
<li>再到第三层后台系统，主要做数据的二次校验，对系统做好保护和限流。这样数据量和请求就进一步减少。</li>
<li>最后在数据层完成数据的强一致性校验。</li>
</ul>
<blockquote>
<p>像漏斗一样，尽量把数据量和请求量一层一层地过滤和减少了。</p>
</blockquote>
<h4 id="分层校验的基本原则是："><a href="#分层校验的基本原则是：" class="headerlink" title="分层校验的基本原则是："></a>分层校验的基本原则是：</h4><ol>
<li>将动态请求的读数据缓存(Cache)在Web端，过滤掉无效的数据读；</li>
<li>对读数据不做强一性校验，减少因为一致性校验产生瓶颈的问题；</li>
<li>对写数据进行基于时间的合理分片，过滤掉过期的失效请求；</li>
<li>对写请求做限流保护，将超出系统承载能力的请求过滤掉。</li>
<li>对写数据进行强一致性校验，只保留最后有效的数据。</li>
</ol>
<blockquote>
<p>分层校验的目的是：在读系统中，尽量减少由于一致性校验带来的系统瓶颈，但是尽量将不影响性能的检查条件提前，如用户是否具有秒杀资格，商品状态是否正常，用户答题是否正确、秒杀是否已经结束、是否非法请求、营销等价物是否充足等；在写数据系统中，主要对写的数据（如“库存”）做一致性检查，最后在数据库层保证数据的最终准确性（如“库存”不能减为负数）。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/18/Mysql%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/18/Mysql%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Mysql阅读笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-06-18 11:55:58" itemprop="dateCreated datePublished" datetime="2020-06-18T11:55:58+08:00">2020-06-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-06-22 21:42:32" itemprop="dateModified" datetime="2020-06-22T21:42:32+08:00">2020-06-22</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="在建立联合索引的时候，如何安排索引内的字段顺序？"><a href="#在建立联合索引的时候，如何安排索引内的字段顺序？" class="headerlink" title="在建立联合索引的时候，如何安排索引内的字段顺序？"></a>在建立联合索引的时候，如何安排索引内的字段顺序？</h3><p>第一考虑的是：索引的复用能力，因为可以支持最左前缀，所以当已经有了（a,b）联合索引后，一般就不需要单独在a上简历索引了。因此，第一原则是如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</p>
<p>第二考虑的原则是空间：例如a字段是比b字段大的，那么我就建议创建一个(a,b)的联合索引和一个(b)的单字段索引。</p>
<h3 id="count这么慢的解释"><a href="#count这么慢的解释" class="headerlink" title="count这么慢的解释"></a>count这么慢的解释</h3><h4 id="分析性能差的别的时候，需要记住这么几个原则："><a href="#分析性能差的别的时候，需要记住这么几个原则：" class="headerlink" title="分析性能差的别的时候，需要记住这么几个原则："></a>分析性能差的别的时候，需要记住这么几个原则：</h4><ol>
<li><p>server层要什么给什么；</p>
</li>
<li><p>InnoDB只给必要的值；</p>
</li>
<li><p>现在的优化器只优化了count(<em>)的语义为“取行数”,其他“显而易见”的优化并没有做。Mysql已经优化过count(</em>)了，直接使用这种用法就可以了。</p>
</li>
</ol>
<p><strong>对于count(主键ID)</strong>来说，InnoDB引擎会遍历整张表，把每一行的ID值都取出来，返回给server层。server层拿到ID后，判断是不可能为空，就按行累加。</p>
<p><strong>对于count(1)</strong>来说，InnoDB引擎遍历整张表，但不取值。server层对于返回的每一个行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
<blockquote>
<p>单看这两个用法的差别的话，你能对比出来，count(1)执行得要比count(主键ID)快。因为从引擎返回id会涉及到解析数据行，以及拷贝字段值的操作。</p>
</blockquote>
<p><strong>对于count(字段)</strong>来说：</p>
<ol>
<li><p>如果这个“字段”是定义为not null 的话，一行行地从记录里面读出这个字段，判断不能为null，按行累加；</p>
</li>
<li><p>如果这个“字段”定义允许为null，那么执行的时候，判断到有可能是null，还要把值取出来再判断一下，不是null才累加。</p>
</li>
</ol>
<p>也就是前面的第一原则，server层要什么字段，InnoDB就返回什么字段。</p>
<ul>
<li>但是count(<em>)是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(</em>)肯定不是null,按行累加。</li>
</ul>
<blockquote>
<p>结论 ：按照效率排序的话，count(字段) &lt; count(主键id) &lt; count(1) ≈ count(<em>),所以尽量使用 count(</em>).</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/15/%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/15/%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">设计秒杀系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2020-06-15 08:55:57 / عُدل: 14:14:50" itemprop="dateCreated datePublished" datetime="2020-06-15T08:55:57+08:00">2020-06-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="秒杀其实主要解决两个问题"><a href="#秒杀其实主要解决两个问题" class="headerlink" title="秒杀其实主要解决两个问题"></a>秒杀其实主要解决两个问题</h3><h4 id="并发读"><a href="#并发读" class="headerlink" title="并发读"></a>并发读</h4><ul>
<li>并发读的核心优化理念是尽量减少用户到服务端来“读”数据，或者让他们读更少的数据；</li>
</ul>
<h4 id="并发写"><a href="#并发写" class="headerlink" title="并发写"></a>并发写</h4><ul>
<li>并发写的处理原则也一样，它要求我们在数据库层面独立出来一个库，做一个库，做特殊处理。另外，我们还要针对秒杀系统做一些保护，针对意料之外的情况设计兜底方案，以防止最坏的情况发生。 </li>
</ul>
<h3 id="设计秒杀系统关注的三点-稳，准，快"><a href="#设计秒杀系统关注的三点-稳，准，快" class="headerlink" title="设计秒杀系统关注的三点 稳，准，快"></a>设计秒杀系统关注的三点 稳，准，快</h3><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><ul>
<li>秒杀及大量的并发读和并发写，因此支持高并发访问这点非常关键</li>
</ul>
<h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><ul>
<li>秒杀中商品减库存的实现方式同样关键。在有限数量的商品在同一时刻被很多倍的请求同时来减库存，减库存又分为“拍下减库存” “付款减库存”以及预扣等几种，在大并发更新的过程中都要保证数据的准确性。</li>
</ul>
<h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><ul>
<li>在实际的操作中会有一些考虑不到的情况，所以要保证系统的高可用和正确性，我们需要设计一个plan B 来进行对最坏情况发生的应急处理。</li>
</ul>
<h3 id="架构原则：”4-要-1-不要”"><a href="#架构原则：”4-要-1-不要”" class="headerlink" title="架构原则：”4 要 1 不要”"></a>架构原则：”4 要 1 不要”</h3><ol>
<li>数据要尽量少<br>所谓“数据要尽量少”，首先是指用户请求的数据能少就少。请求的数据包括上传给系统的数据和系统返回给用户的数据（通常就是网页）。</li>
</ol>
<p>为啥“数据要尽量少”呢？因为首先这些数据在网络上传输需要时间，其次不管是请求数据还是返回数据都需要服务器做处理，而服务器在写网络时通常都要做压缩和字符编码，这些都非常消耗CPU，所以减少传输的数据量可以显著减少CPU的使用。例如，我们可以简化秒杀页面的大小去掉不必要的页面装修效果，等等。</p>
<p>其次，“数据要尽量少”还要求系统依赖的数据能少就少，包括系统完成某些业务逻辑需要读取和保存的数据，这些数据一般是和后台服务以及数据库打交道的。调用其他服务会涉及数据的序列化和反序列化，而这也是CPU的一大杀手，同样也会增加延时。而且，数据库本身也容易成为一个瓶颈，所以和数据库打交道越少越好，数据越简单，越小则越好。</p>
<ol start="2">
<li><p>请求数量要尽量少<br>用户请求的页面返回后，浏览器渲染这个页面还要包含其他的额外请求，比如说，这个页面依赖CSS/JavaScript，图片 以及Ajax请求等等都定义为 “额外请求”,这些额外请求应该尽量少。因为浏览器每发出一个请求都多少会有一些消耗，例如建立连接要做三次握手，有的时候有页面依赖或者连接限制，一些请求（例如Javascript）还需要串行加载等。另外，如果不同请求的域名不一样的话，还涉及这些域名的DNS解析，可能会耗时更久。所以减少请求数可以显著减少以上这些因素导致的资源消耗。</p>
</li>
<li><p>路径要尽量短<br>所谓“路径”，就是用户发出请求到返回数据这个过程中，需求经过的中间的节点数。</p>
</li>
</ol>
<p>通常，这些节点可以表示为一个系统或者一个新的Socket链接（比如代理服务器只是创建一个新的Socket连接来转发请求）。每经过一个节点，一般都会产生一个新的Socket连接。</p>
<p>然而，每增加一个连接都会增加新的不确定性。从概率统计上来说，加入一次请求经过5个节点，每个节点的可用性是99%的话，那么整个请求的可用性是：99.9%的5次方，约等于99.5%。</p>
<p>所以缩短请求路径不仅可以增加可用性，同样可以有效提升性能（减少中间节点可以减少数据的序列化与反序列化），并减少延时（可以减少网络传输耗时）。</p>
<p>要缩短访问路径有一种方法，就是多个相互强依赖的应用合并部署在一起，把远程过程调用（RPC）编程JVM内部之间的方法调用。</p>
<ol start="4">
<li>依赖要尽量少<br>所谓依赖，指的是要完成一次用户请求必须依赖的系统或者服务，这里的依赖指的是强依赖。</li>
</ol>
<p>举个例子，比如说你要展示秒杀页面，而这个页面必须强依赖商品信息，用户信息，还有其它如优惠券，成交列表等这些对秒杀不是非要不可的信息（弱依赖），这些若依赖在紧急情况下就可以去掉。</p>
<p>要减少依赖，我们可以给系统进行分级，比如0级系统，1级系统，2级系统，3级系统，0级系统如果是最重要的系统，那么0级系统强依赖的系统也统一是最重要的系统，以此类推。</p>
<blockquote>
<p>0级系统要尽量减少对1级系统的强依赖，防止重要的系统被不重要的系统拖垮。例如支付系统是0级系统，而优惠劵是1级系统的话，在极端情况下可以把优惠劵给降级，防止支付系统被优惠劵这个1级系统给拖垮。</p>
</blockquote>
<ol start="5">
<li>不要有单点<br>系统中的单点可以说是系统架构上的一个大忌，因为单点意味着没有备份，风险不可控，我们设计分布式系统最重要的原则就是 “消除单点”。</li>
</ol>
<p>那如何避免单点呢？ 最重要的是避免将服务的状态和机器绑定，即把服务无状态化，这样服务就可以在机器中随意移动。</p>
<p>如何把服务的状态和机器解耦呢？这里也有很多实现方式。例如把和机器相关的配置动态化，这些参数可以通过配置中心来动态推送，在服务启动时动态拉取下来，我们在这些配置中心设置一些规则来方便地改变这些映射关系。</p>
<p>应用无状态化是有效避免单点的一种方式，但是像存储服务本身很难无状态化，因为数据要存储在磁盘上，本身就要和机器绑定，那么这种场景一般要通过冗余多个备份的方式来解决单点问题。</p>
<h3 id="（1w-s-到了-10w-s-的量级）架构"><a href="#（1w-s-到了-10w-s-的量级）架构" class="headerlink" title="（1w/s 到了 10w/s 的量级）架构"></a>（1w/s 到了 10w/s 的量级）架构</h3><ol>
<li><p>把秒杀系统独立出来单独打造个系统，这样就可以有针对性地做优化，例如这个独立出来的系统就减少了店铺装修的功能，减少了页面的复杂度。</p>
</li>
<li><p>在系统部署上也独立做一个机器集群，这样秒杀的大流量就不会影响到正常的商品购买集群的机器负载；</p>
</li>
<li><p>将热点数据（如库存数据）单独放到一个缓存系统中，以提高“读性能”；</p>
</li>
<li><p>增加秒杀答题，防止有秒杀器抢单。</p>
</li>
</ol>
<h3 id="升级架构"><a href="#升级架构" class="headerlink" title="升级架构"></a>升级架构</h3><ol>
<li><p>对页面进行彻底的动静分离，使得用户秒杀时不需要刷新整个页面，而只需要点击抢宝按钮，借此把页面刷新的数据降到最少；</p>
</li>
<li><p>在服务端对秒杀商品进行本地缓存，不需要再调用依赖系统的后台服务获取数据，甚至不需要去公共的缓存集群中查询数据，这样不仅可以减少系统调用，而且能够避免压垮公共缓存集群。</p>
</li>
<li><p>增加系统限流保护，防止最坏情况发生。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/09/Mysql%E7%9A%84SQL%E5%88%86%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/09/Mysql%E7%9A%84SQL%E5%88%86%E7%B1%BB/" class="post-title-link" itemprop="url">Mysql的SQL分类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-06-09 16:26:40" itemprop="dateCreated datePublished" datetime="2020-06-09T16:26:40+08:00">2020-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-06-10 12:51:24" itemprop="dateModified" datetime="2020-06-10T12:51:24+08:00">2020-06-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="SQL语句主要可以划分为以下3个类别。"><a href="#SQL语句主要可以划分为以下3个类别。" class="headerlink" title="SQL语句主要可以划分为以下3个类别。"></a>SQL语句主要可以划分为以下3个类别。</h3><h4 id="DDL语句："><a href="#DDL语句：" class="headerlink" title="DDL语句："></a>DDL语句：</h4><p>DDL是数据定义语言的缩写，数据定义语言，这些语句定义了不同的数据段，数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括create、drop、alter等。简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和DML语言的最大区别是DML只是对表内部数据的操作。而不涉及到表的定义，结构的修改，更不会涉及到其它对象。DDL语句更多的被数据库管理员（DBA）所使用。</p>
<h4 id="DML语句："><a href="#DML语句：" class="headerlink" title="DML语句："></a>DML语句：</h4><p>数据操纵语句，用于添加、删除、更新和查询数据库记录、并检查数据完整性，常用的语句关键字主要包括insert、delete、update和select等。（增添改查）</p>
<h4 id="DCL语句："><a href="#DCL语句：" class="headerlink" title="DCL语句："></a>DCL语句：</h4><p>数据库控制语句，用于控制不同数据段直接的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的访问权限和安全级别。主要的语句关键字包括grant,revoke等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/28/Join%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/28/Join%E6%9F%A5%E8%AF%A2/" class="post-title-link" itemprop="url">Join查询</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2020-05-28 19:47:32" itemprop="dateCreated datePublished" datetime="2020-05-28T19:47:32+08:00">2020-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2020-06-09 16:26:49" itemprop="dateModified" datetime="2020-06-09T16:26:49+08:00">2020-06-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>select * from t1 straight_join t2 on (t1.a=t2.a);</p>
<h3 id="join执行的流程"><a href="#join执行的流程" class="headerlink" title="join执行的流程"></a>join执行的流程</h3><ol>
<li><p>从表t1中读入一行数据R；</p>
</li>
<li><p>从数据行R中,取出a字段到表t2里去查找；</p>
</li>
<li><p>取出表t2中满足条件的行，跟R组成一行，作为结果集的一部分；</p>
</li>
<li><p>重复执行步骤1到3，直到表t1的末尾循环结束。</p>
</li>
</ol>
<p>这个过程是先遍历表t1，然后根据从表t1中取出的每行数据中的a值，去表t2中查找满足条件的记录。在形式上，这个过程就跟我们写程序的嵌套查询类似，并且可以用上被驱动表的索引，所以我们称之为“Index Nested-Loop Join”,简称NLJ.</p>
<h3 id="怎么选择驱动表？"><a href="#怎么选择驱动表？" class="headerlink" title="怎么选择驱动表？"></a>怎么选择驱动表？</h3><ol>
<li>使用join语句，性能比强行拆成多个单表执行SQl语句的性能要好；</li>
<li>如果使用join语句的话，需要让小表做驱动表。</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/11/InnoDB%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/11/InnoDB%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/" class="post-title-link" itemprop="url">索引的处理流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2020-05-11 16:06:36 / عُدل: 16:48:46" itemprop="dateCreated datePublished" datetime="2020-05-11T16:06:36+08:00">2020-05-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="基于主键索引和普通索引的查询有什么区别？"><a href="#基于主键索引和普通索引的查询有什么区别？" class="headerlink" title="基于主键索引和普通索引的查询有什么区别？"></a>基于主键索引和普通索引的查询有什么区别？</h3><ul>
<li><p>如果语句是 select * from T where ID=500,即主键查询方式，则只需要搜索ID这颗树B+树；</p>
</li>
<li><p>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到ID的值为500，再到 ID 索引树搜索一次。这个过程称为回表。 </p>
</li>
</ul>
<p>也就是说，基于非主键索引的查询需要扫描一棵索引树。因此 我们在应用中应该尽量使用主键查询。</p>
<h3 id="什么条件下可以使用-change-buffer-呢？"><a href="#什么条件下可以使用-change-buffer-呢？" class="headerlink" title="什么条件下可以使用 change buffer 呢？"></a>什么条件下可以使用 change buffer 呢？</h3><p>唯一索引的更新就不能使用change buffer,实际上也只有普通索引可以使用。</p>
<p>change buffer用的是buffer pool里的内存，因此不能无限增大。change buffer的大小，可以通过参数innodb_change_buffer_max_size来动态设置。这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。</p>
<h3 id="如果要在这张表中插入一个新记录-4-400-的话，InnoDB-的处理流程是怎样的。"><a href="#如果要在这张表中插入一个新记录-4-400-的话，InnoDB-的处理流程是怎样的。" class="headerlink" title="如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的。"></a>如果要在这张表中插入一个新记录 (4,400) 的话，InnoDB 的处理流程是怎样的。</h3><h4 id="第一种情况是，这个记录要更新的目标页在内存中。这时，InnoDB的处理流程如下："><a href="#第一种情况是，这个记录要更新的目标页在内存中。这时，InnoDB的处理流程如下：" class="headerlink" title="第一种情况是，这个记录要更新的目标页在内存中。这时，InnoDB的处理流程如下："></a>第一种情况是，这个记录要更新的目标页在内存中。这时，InnoDB的处理流程如下：</h4><ul>
<li><p>对于唯一索引来说，找到3和5之间的位置，判断到没有冲突，插入这个值，语句执行结束；</p>
</li>
<li><p>对于普通索引来说，找到3和5之间的位置，插入这个值，语句执行结束。</p>
</li>
</ul>
<p>这样看来，普通索引和唯一索引对更新语句性能影响的差别，只是一个判断，只会耗费微小的CPU时间。</p>
<h4 id="第二种情况是，这个记录要更新的目标页不在内存中。这时InnoDB的处理流程如下："><a href="#第二种情况是，这个记录要更新的目标页不在内存中。这时InnoDB的处理流程如下：" class="headerlink" title="第二种情况是，这个记录要更新的目标页不在内存中。这时InnoDB的处理流程如下："></a>第二种情况是，这个记录要更新的目标页不在内存中。这时InnoDB的处理流程如下：</h4><ul>
<li><p>对于唯一索引来说，需要将数据页读入内存，判断没有冲突，插入这个值，语句执行结束；</p>
</li>
<li><p>对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。</p>
</li>
</ul>
<p>将数据从磁盘读入内存及随机IO的访问，是数据库里面成本最高的操作之一。change buffer因为减少了随机磁盘访问，所以对更新性能的提升会很明显。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/11/RabbitMQ%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="GIO">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="十二月的doge">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/11/RabbitMQ%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">RabbitMQ的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2020-05-11 08:46:21 / عُدل: 16:07:36" itemprop="dateCreated datePublished" datetime="2020-05-11T08:46:21+08:00">2020-05-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-消息基于什么传输？"><a href="#1-消息基于什么传输？" class="headerlink" title="1.消息基于什么传输？"></a>1.消息基于什么传输？</h3><p>由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使用信道的<br>方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</p>
<h3 id="2-消息如何分布？"><a href="#2-消息如何分布？" class="headerlink" title="2.消息如何分布？"></a>2.消息如何分布？</h3><p>若该队列至少有一个消费者订阅，消息将以循环(round-robin)的方式发送给消费者。每条消息只会分<br>发给一个订阅的消费者（前提是消费者能够正常处理消息并进行确认）。</p>
<h3 id="3-如何确保消息正确地发送至RabbitMQ"><a href="#3-如何确保消息正确地发送至RabbitMQ" class="headerlink" title="3.如何确保消息正确地发送至RabbitMQ?"></a>3.如何确保消息正确地发送至RabbitMQ?</h3><p>RabbitMQ使用发送方确认模式，确保消息正确地发送到RabbitMQ。发送方确认模式：将信道设置成confirm<br>模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。一旦消息被投递到目<br>的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（发送消息唯一<br>ID）。如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack（not acknowledged，未确认<br>）消息。发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息<br>到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</p>
<h3 id="4-如何确保消息接收方消费了消息？"><a href="#4-如何确保消息接收方消费了消息？" class="headerlink" title="4.如何确保消息接收方消费了消息？"></a>4.如何确保消息接收方消费了消息？</h3><p>接收方消息确认机制：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）<br>。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。这里并没有用到超时机制，RabbitMQ<br>仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了<br>Consumer足够长的时间来处理消息。<br>会有以下几种特殊情况：</p>
<ul>
<li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后<br>重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要根据bizId去重）</li>
<li>如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该<br>消费者分发更多的消息。</li>
</ul>
<h3 id="5-如何避免消息重复投递或重复消费？"><a href="#5-如何避免消息重复投递或重复消费？" class="headerlink" title="5. 如何避免消息重复投递或重复消费？"></a>5. 如何避免消息重复投递或重复消费？</h3><p>在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重和幂等的依据（消息投递失败并重传），避免重复的消息进入队列；在消息消费时，要求消息体中必须要有一个bizId（对于同一业务全局唯一，如支付ID、订单ID、帖子ID等）作为去重和幂等的依据，避免同一条消息被重复消费。</p>
<p>这个问题针对业务场景来答分以下几点：</p>
<ul>
<li><p>比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。</p>
</li>
<li><p>再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。</p>
</li>
<li><p>如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将&lt;id,message&gt;以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。</p>
</li>
</ul>
<h3 id="6-生产者丢数据"><a href="#6-生产者丢数据" class="headerlink" title="6.生产者丢数据"></a>6.生产者丢数据</h3><p>生产者的消息没有投递到MQ中怎么办？从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。</p>
<p>transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。</p>
<p>然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作</p>
<h3 id="7-消息队列丢数据"><a href="#7-消息队列丢数据" class="headerlink" title="7.消息队列丢数据"></a>7.消息队列丢数据</h3><p>处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发。</p>
<p>那么如何持久化呢？<br>①、将queue的持久化标识durable设置为true,则代表是一个持久的队列.<br>②、发送消息的时候将deliveryMode=2</p>
<p>这样设置以后，rabbitMQ就算挂了，重启后也能恢复数据。在消息还没有持久化到硬盘时，可能服务已经死掉，这种情况可以通过引入mirrored-queue即镜像队列，但也不能保证消息百分百不丢失（整个集群都挂掉）</p>
<h3 id="8-消费者丢数据"><a href="#8-消费者丢数据" class="headerlink" title="8.消费者丢数据"></a>8.消费者丢数据</h3><p>启用手动确认模式可以解决这个问题</p>
<ul>
<li><p>自动确认模式，消费者挂掉，待ack的消息回归到队列中。消费者抛出异常，消息会不断的被重发，直到处理成功。不会丢失消息，即便服务挂掉，没有处理完成的消息会重回队列，但是异常会让消息不断重试。</p>
</li>
<li><p>手动确认模式，如果消费者来不及处理就死掉时，没有响应ack时会重复发送一条信息给其他消费者；如果监听程序处理异常了，且未对异常进行捕获，会一直重复接收消息，然后一直抛异常；如果对异常进行了捕获，但是没有在finally里ack，也会一直重复发送消息(重试机制)。</p>
</li>
<li><p>不确认模式，acknowledge=”none” 不使用确认机制，只要消息发送完成会立即在队列移除，无论客户端异常还是断开，只要发送完就移除，不会重发。</p>
</li>
</ul>
<h3 id="使用消息队列会有什么缺点？"><a href="#使用消息队列会有什么缺点？" class="headerlink" title="使用消息队列会有什么缺点？"></a>使用消息队列会有什么缺点？</h3><ul>
<li><p>系统可用性降低:你想啊，本来其他系统只要运行好好的，那你的系统就是正常的。现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低。</p>
</li>
<li><p>系统复杂性增加:要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。因此，需要考虑的东西更多，系统复杂性增大。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="الصفحة التالية"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          المحتويات
        </li>
        <li class="sidebar-nav-overview">
          عام
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">GIO</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">المقالات</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">الوسوم</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">GIO</span>
</div>
  <div class="powered-by">تطبيق الموقع <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
